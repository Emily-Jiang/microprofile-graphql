//
// Copyright (c) 2019 Contributors to the Eclipse Foundation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

[[errorhandling]]

== Error Handling

In GraphQL applications most errors will either be client, server or transport errors.

Client errors occur when the client has submitted an invalid request. Examples of client errors include specifying a
query or mutation that does not exist, requesting a field on an entity that does not exist, specifying the wrong type of
data (such as specifying an `Int` when the schema requires a `String`), etc.

Server errors occur when the request is valid and is properly transported to the server application but the response is
unexpected or unable to be fulfilled. Examples of server errors include bugs in the application code, a back-end
resource such as a database is down, etc.

Transport errors occur when the request cannot be delivered to the server or when the response cannot be delivered to
the client. Examples of transport errors include network disruption, mis-configured firewalls, etc.

The MP GraphQL specification addresses the handling of client and server errors. Transport error handling is beyond the
scope of this document.

=== Client Errors

Client errors must be handled automatically by the implementation. Invalid requests must never result in user
application code invocation.  Instead, the implementation must provide the client with an error message that indicates
why the client request was invalid.

=== Server Errors

If the client request is valid, then the implementation must invoke the correct query or mutation method in the user
application. The user application can indicate that an error has occurred by throwing an exception (checked or
unchecked).  When the user application throws and exception, the implementation must send back a response that includes
an error message.

The user may determine the error message that is sent back to the client in two ways:
- Throw an instance of `GraphQLException` or a subclass. The implementation must send the exception's message text to 
the client.  Optionally, the user can specify an `ExceptionType` in the exception which must also be sent to the client
if specified.
- Specify the default error message to use when any other (non-`GraphQLException`) exception is thrown. This is set
using the MicroProfile Config property, `mp.graphql.defaultErrorMessage`.

=== Partial Results

It is possible in GraphQL to send back some results even though the overall request may have failed. 
This is possible by passing the partial results to the `GraphQLException` (or subclass of `GraphQLException`) that is
thrown by the query or mutation method.  For example:

```
@Query
public Collection<SuperHero> allHeroesFromCalifornia() throws GraphQLException {
    List<SuperHero> westCoastHeroes = new ArrayList<>();
    try {
        for (SuperHero hero : database.getAllHeroes()) {
            if (hero.getPrimaryLocation().contains("California")) {
                westCoastHeroes.add(hero);
            }
        }
    } catch (Exception ex) {
        throw new GraphQLException(ex, westCoastHeroes);
    }
    return westCoastHeroes;
}
```

If an exception is thrown while iterating over of the database collection of heroes or while checking a hero's location,
all previously-processed heroes will still be in the list and will be displayed to the client along with the error
data.

Note that the `partialResults` object passed to the `GraphQLException` must match the return type of the query/mutation
method from which it is thrown. Otherwise the implementation must throw a `ClassCastException` internally resulting in
a much less usable result returned to the client.

It is also possible to send partial results when using multiple methods and the `@Source` annotation. Here is an
example:

```
@Query
public Collection<SuperHero> allHeroes() {
    return database.getAllHeroes();
}

@Query
public Location currentLocation(@Source SuperHero hero) throws GraphQLException {
    if (hero.hasLocationBlockingPower()) {
        throw new GraphQLException("Unable to determine location for " + hero.getName());
    }
    return database.getLocationForHero(hero);
}
```

Suppose the client issued this query:
```
query allHeroes {
    allHeroes {
        name
        currentLocation
    }
}
```

In this case, if there are any heroes that have a location blocking power, one or more errors will be returned to the
client. However, the names of all of the heroes in the database will be returned as well as the location of all heroes
to do not have a location blocking power.
